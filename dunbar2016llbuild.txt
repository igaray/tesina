\addcontentsline{toc}{section}{A New Architecture for Building Software}
\section*{2016 LLVM Developers’ Meeting: D. Dunbar “A New Architecture for Building Software”}
\cite{dunbar2016}

## Overview

Los tiempos de compilacion impactan a los desarrolladores.
Clang fue diseñado desde el principio para ser un compilador rapido de C/C++.
La estrategia inicial fue
- tunear la implementacion de lex y parseo,
- enfocarse en tener un flujo de ejecucion con -O0 con muy poca sobrecarga, sin optimizaciones innecesarias,
- rediseñar la implementacion de PCH (archivos de encabezado pre-compildos), intentando obtener la cantidad minima necesaria de los archivos de encabezado,
- integrar el ensamblador en el compilador, evitando el tiempo utilizado para emitir codigo ensamblador y luego cargarlo en el ensamblador.

Esta estrategia fue exigtosa, y en sus inicios clang era 3x mas rapido que gcc, pero con el tiempo esa diferencia se fue achicando, en parte porque gcc mismo mejoro sus tiempos de compilacion pero sobre todo porque la performance es un atributo que sufre regresiones con la adicion de funcionalidad.

A la hora de mejorar el tiempo de compilacion, hay varias opcionesÑ
- compilacion distribuida
- cacheo mejorado, idealmente distribuido y compartido
- hacer menos trabajo

En el caso de clang, hay cosas que se pueden implementar hoy sin grandes cambios, tales como reutilizar el frontend del compilador a lo largo de la compilacion de varios archivos que comparten los mismo flags de compilacion, permitiendo que el frontend cachee mejor, e.g. stat syscalls y otra metainformacion, o PCHs para archivos que se editan frecuentemente.

Aunque esto funciona, el problema es que el compilador no tiene control sobre como es invocado, dado que esto depende del build system.

Una propuesta es construir un servicio de compilador, pero esto presenta otros problemas.

## Como se construye software hoy

Para la mayoria de los lenguajes, se sigue un modelo de build tradicional basado en unix
- el compilador corre como un proceso separado
- mecanismos primitivos para comunicar dependencias entre el build system y el compilador:
  - el build system informa las entradas y salidas a traves de argumentos de linea de comando
  - ausencia de un buen mecanismo mediante el cual el compilador puede informar nuevas dependencias al build system
  - entrada/salida fija: existe un conjunto limitado de lugares en los cuales se puedeen leer y escribir datos; si el compilador quisera cachear algo durante la sesion de compilacion, no hay un lugar estandard o consensuado donde hacerlo.

Desde cierto punto de vista, esto constituye un contrato API, pero es un API que no ha cambiado en decadas.

## Como se podria construir software

Que sucederia si estuviesemos dispuestos a rompar este API?
Cosas que se podrian hacer:
- tablas de lookup ad-hoc:
  en muchos momentos del ciclo de compilacion a traves del build, el compilador computa informacion que podria ser acelerado a traves de una tabla de lookup, y si esa tabla pudiese ser persistida a lo largo de varias sesiones de compilacion se podria acelerar el build.
  Hoy, esto involucraria serializar a disco y volver a leerlo, mitigando la reduccion en tiempo de compilacion.
- salida temprana del proceso de compilacion a traves firmas de codigo:
  se podria implementar la capacidad de tomar la signatura del IR LLVM que emite el codegen, y si la firma es igual a la ultima vez que se compilo ese archivo, se saltea ese backend.
  Esto puede hacer una gran diferencia, en la mayoria de los compiladores el backend de generacion de codigo domina los tiempos de compilacion, si lo que se cambia es un comentario y el codigo objeto que obtendriamos seria exactamente igual.
- resolucion de instanciaciones de templates/monomorfizacion redundantes:
  se pasa mucho tiempo en un build repitiendo trabajo al instanciar el mismo template, creandolos, verificando los tipos, generando codigo, y finalmente pasando todo el resultado al linker, solo para que elimine la mayoria.

Para todos estos casos lo que se requiere es evolucionar el API entre el compilador y el build system.

## Y el cache de modulos?

Clang tiene un cache de modulos, y es un ejemplo de un sistema que cachea algo a lo largo de todo el build.
- automaticamente hace el build de modulos cuando es necesario
- comparte los resultados a lo largo de todo el build
- no se requiere modificar el sistema de build

Pero este no es un buen ejemplo porque involucra una complejidad de implementacion considerable.
- utiliza lockeo de archivos POSIX para coordinar
- utiliza su propio esquema de manejo de consistencia de cache, tiene pocas herramientas de debuggeo, y tiene que observar los archivos y entender cuando necesita rehacer el build de modulos
- tiene su propio mecanismo de desalojo de cacheo
- es opaco al scheduler del sistema de build, si uno comienza un conjunto de tareas de build y todas requieren del mismo modulo, desde el punto de vista del sistema de build, va a bloquear esperando a esos modulos, pero podria estar haciendo mas trabajo

## El modelo ideal de construccion de software

Lo que realmente se necesita es un API flexible entre el compilador y el sistema de build.

Objetivos:

- deberia ser facil compartir trabajo redundante, si hay un lugar en el compilador que realiza trabajo que es redundante a lo largo del ciclo de vida del build, deberia ser facil implementar eso
- optimizar el compilador para el build entero: a la mayoria de los usuarios, exceptuando de los ingenieros de compiladores, no les importa los archivos objetos, les importa el producto final.
  esta es la situacion que deberia optimizarse, ser rapido para el build completo
- conversamente, deberia ser posible optimizar el sistema de build a traves de un API de compilador rico.
  si el compilador se da cuenta que podria realizar trabajo en paralelo, seria ideal que se le pueda comunicar con sistema de build para poder ingresar la tarea en el schedule de manera efectiva
- builds incrementales consistentes y con una arquitectura debuggeable: uno de los beneficios de la arquitectura actual es que se hacen grandes esfuerzos para mantener una garantia fuerte de que el mismo input producira exactamente el mismo archivo de salida, porque es la base de tener builds reproducibles
- necesito poder integrar el compilador con el sistema de build

Requiere:
- un compilador basado en librerias, i.e. un compilador cuya architectura tiene en cuenta su reutilizacion
- un sistema de build extensible, i.e. un sistema de build que ha sido diseñado con la idea de que las herramientas con las que interactua deberian poder conectar mas profundamente que solo a traves de un subproceso
  cuando se invoca make o ninja, esperan que se los invoque a traves de un subproceso, y hay pocas maneras de poder interactuar con ellos
- plugins de compilador

## Presentando llbuild

Objetivos:
- ignore build description / input language
  not make a new syntax as a replacement for cmake
  most build systems, somewhere inside they have a little engine
  that is capable of evaluating a dependency graph
  that engine is usually fairly simple
- with llbuild focus on building a powerful engine
  - support work being discovered on the fly
    very few build can support the situation where your executing
    some task and during the execution of that task you realize you
    need to do more work
  - scale to millions of tasks
    because the goal was to take our existing build and partition
    them into much smaller pieces to be able to get better
    incremental beehaviour it really needed to be able to scale
  - support sophisticated scheduling
    during a build of llvm we have a lot of cpu boudn stuff running
    the compipler, and we have a lot of io bound stuff, like runner
    the linker , which sucks in all the object files
  - powerful debugging tools
- support a pluggable task api

### llbuild architecture

- flexible underlying core engine
  the llvm ir equivalent, a common denominator between the high level
  things, build systems, and the lower level optimization
  - library for persistent, incremental computation
  - heavily inspired by a haskell build system called shake
  - low-level
    - inputs and outputs are byte strings
      there are no files, just strings of bytes, and the expectation
      that as a client, you'll encode data in those if necessary
    - functions are abstract
    - use c++ api between tasks
  - on top of this core: hiher-level build systems are built on the
    core there's a ninja implementation on top of this, a package
    manager

### llbuild engine

what would it mean to factor out this kind of more minimal engine
what it actually looks like

- minimal, functional model
  four basic concepts
  - keys: unambiguos name for some comutation you want to perform
  - value: the result of a computation
  - rule: how to produce a value for a key
  - task: a runing instance of a rule
    - a task can request other input keys as part of its work

the core engine can be used directly for general purpose
computation

recursive functions foprma a natural graph each result
depends on the recursive inputs

### example: ackerman

to build ackerman we encode the ackerman invocation we want
to make as a key, we encode the integer result as a value,
then we take those keys and we map them to tasks using our
rules, and then the tasks themselves implement the ackerman
function

we have simple wrapper struct that wraps the integer pair
that the arguments,

it has a couple functions to convert it to and from a
serialized representation the value is the same thing

where it gets more interesting with rules

the way llbuild works is you give it a delegate,

it can handle this idea of work being generated on the fly,
and the reason it can do it is you jhust give it a delegate,
and you give it a function that provides it rules when it
wants them

so unlike a ninja file where all of the rules are present in
advance, from the engines perspective it just has a function
to request rules as they come in

so in this case our function just decodes that key and will
create a task if its requested

it has some other stuff like it can report to you if it
found a cycle

so tasks are where the real work happens

the way that the tasks work is that the engine will call
back into your tasks as interesting stuff happens happens

when a task is started, youre notified

when the engine has computed a result you asked for, then
its given to you

when all of the inputs that your task has asked for have
been computed, then it shluld complete

## Una arquitectura nueva

Requiere:
- un compilador basado en librerias
- un sistema de build extensible
- un sistema de plugins de compilador

## What's the status of this 2 years later?

Funny you should ask! llbuild is alive and strong, and now
powers the default build system used in Xcode 10. Getting
the "new architecture" proposed here off the ground has
continued to be difficult, mostly due to the challenge of
refactoring the existing compilers, and that the payoffs
only start to get realized once a large amount of work has
been done. It is hard to unwind 40 years of CS-precedent for
how compilers are built overnight, but I am still optimistic
about the potential here!

... and probably worth adding: since this was published
llbuild's own Ninja implementation usually outperforms the
actual Ninja on most real world situations we've seen (such
as building LLVM/Clang on a variety of different hardware).

\end{Verbatim}